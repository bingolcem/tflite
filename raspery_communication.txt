adjustEnvironment.py

import bluetoothctl
import time
import os
import threading

def sendTxt(macAddress):
    os.system('obexftp --nopath --noconn --uuid none --bluetooth ' + macAddress + ' --channel 12 -p /home/pi/Desktop/communication/verification.txt')

def bluetoothInterface():
    bl = bluetoothctl.Bluetoothctl()
    bl.start_scan()
    print("Scanning for 10 second...")
    for i in range(0, 10):
        time.sleep(1)
    print("Ready!")
    device = bl.get_available_devices()

    ban_list = ['RSSI','TxPower','ManufacturerData']
    i = 0
    ban_index = []
    while i < len(device):
        if (device[i]['name'] == device[i]['mac_address'].replace(':','-')):
            ban_index.append(i)
        i += 1
    for ban in ban_list:
        i = 0
        while i < len(device):
            if ban in device[i]['name']:
                ban_index.append(i)
            i += 1
    ban_index.sort()
    for i in range(len(ban_index)):
        device.pop(ban_index[i]-i)


    names = [i['name'] for i in device]
    devices= list(set([i['mac_address'] for i in device]))
    thread=[None]*len(devices)


    for i in range(len(devices)):
        print(devices[i])
        thread[i]=threading.Thread(target=(sendTxt), args=(devices[i],))
        thread[i].start()
        if (i+1)%5==0:
            thread[i].join()
    print('done!')
--------------------------------------
blueD.py

# simple inquiry example
import bluetooth

serverMACAddress = 'F0:EE:10:9C:9D:9F'
port = 3
s = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
s.connect((serverMACAddress, port))
while 1:
    text = "afasdfa" # Note change to the old (Python 2) raw_input
    if text == "quit":
        break
    s.send(text)
sock.close()

-------------------------------
bluetoothctl.py

import time
import pexpect
import subprocess
import sys

class BluetoothctlError(Exception):
    """This exception is raised, when bluetoothctl fails to start."""
    pass


class Bluetoothctl:
    """A wrapper for bluetoothctl utility."""

    def __init__(self):
        out = subprocess.check_output("rfkill unblock bluetooth", shell = True)
        self.child = pexpect.spawn("bluetoothctl", echo = False)

    def get_output(self, command, pause = 0):
        """Run a command in bluetoothctl prompt, return output as a list of lines."""
        self.child.send(command + "\n")
        time.sleep(pause)
        start_failed = self.child.expect(["bluetooth", pexpect.EOF])

        if start_failed:
            raise BluetoothctlError("Bluetoothctl failed after running " + command)

        return str(self.child.before).split("\\r\\n")

    def start_scan(self):
        """Start bluetooth scanning process."""
        try:
            out = self.get_output("scan on")
        except BluetoothctlError:
            print("error")
            return None

    def make_discoverable(self):
        """Make device discoverable."""
        try:
            out = self.get_output("discoverable on")
        except BluetoothctlError:
            print("error")
            return None
    
    def make_pairable(self):
        """Make device pariable."""
        try:
            out = self.get_output("pairable on")
        except BluetoothctlError:
            print("error")
            return None

    def parse_device_info(self, info_string):
        """Parse a string corresponding to a device."""
        device = {}
        block_list = ["[\x1b[0;", "removed"]
        string_valid = not any(keyword in info_string for keyword in block_list)
        if string_valid:
            try:
                device_position = info_string.index("Device")
            except ValueError:
                pass
            else:
                if device_position > -1:
                    attribute_list = info_string[device_position:].split(" ", 2)
                    device = {
                        "mac_address": attribute_list[1],
                        "name": attribute_list[2]
                    }
        return device

    def get_available_devices(self):
        """Return a list of tuples of paired and discoverable devices."""
        try:
            out = self.get_output("devices")
        except BluetoothctlError:
            print("error")
            return None
        else:
            available_devices = []
            for line in out:
                device = self.parse_device_info(line)
                if device:
                    print(device)
                    available_devices.append(device)

            return available_devices

    def get_paired_devices(self):
        """Return a list of tuples of paired devices."""
        try:
            out = self.get_output("paired-devices")
        except BluetoothctlError:
            print("error")
            return None
        else:
            paired_devices = []
            for line in out:
                device = self.parse_device_info(line)
                if device:
                    paired_devices.append(device)

            return paired_devices

    def get_discoverable_devices(self):
        """Filter paired devices out of available."""
        available = self.get_available_devices()
        paired = self.get_paired_devices()

        return [d for d in available if d not in paired]

    def get_device_info(self, mac_address):
        """Get device info by mac address."""
        try:
            out = self.get_output("info " + mac_address)
        except BluetoothctlError:
            print("error")
            return None
        else:
            return out

    def pair(self, mac_address):
        """Try to pair with a device by mac address."""
        try:
            out = self.get_output("pair " + mac_address, 4)
        except BluetoothctlError:
            print("error")
            return None
        else:
            res = self.child.expect(["Failed to pair", "Pairing successful", pexpect.EOF])
            success = True if res == 1 else False
            return success

    def remove(self, mac_address):
        """Remove paired device by mac address, return success of the operation."""
        try:
            out = self.get_output("remove " + mac_address, 3)
        except BluetoothctlError:
            print("error")
            return None
        else:
            res = self.child.expect(["not available", "Device has been removed", pexpect.EOF])
            success = True if res == 1 else False
            return success

    def connect(self, mac_address):
        """Try to connect to a device by mac address."""
        try:
            out = self.get_output("connect " + mac_address, 2)
        except BluetoothctlError:
            print("error")
            return None
        else:
            res = self.child.expect(["Failed to connect", "Connection successful", pexpect.EOF])
            success = True if res == 1 else False
            return success

    def disconnect(self, mac_address):
        """Try to disconnect to a device by mac address."""
        try:
            out = self.get_output("disconnect " + mac_address, 2)
        except BluetoothctlError:
            print("error")
            return None
        else:
            res = self.child.expect(["Failed to disconnect", "Successful disconnected", pexpect.EOF])
            success = True if res == 1 else False
            return success
-----------------------------------------------
bluetoothInterface.py

import bluetoothctl
import time
import os
import threading

def sendTxt(macAddress):
    os.system('obexftp --nopath --noconn --uuid none --bluetooth ' + macAddress + ' --channel 12 -p /home/pi/Desktop/communication/verification.txt')

def bluetoothInterface():
    bl = bluetoothctl.Bluetoothctl()
    bl.start_scan()
    print("Scanning for 10 second...")
    for i in range(0, 10):
        time.sleep(1)
    print("Ready!")
    device = bl.get_available_devices()

    ban_list = ['RSSI','TxPower','ManufacturerData']
    i = 0
    ban_index = []
    while i < len(device):
        if (device[i]['name'] == device[i]['mac_address'].replace(':','-')):
            ban_index.append(i)
        i += 1
    for ban in ban_list:
        i = 0
        while i < len(device):
            if ban in device[i]['name']:
                ban_index.append(i)
            i += 1
    ban_index.sort()
    for i in range(len(ban_index)):
        device.pop(ban_index[i]-i)


    names = [i['name'] for i in device]
    devices= list(set([i['mac_address'] for i in device]))
    thread=[None]*len(devices)


    for i in range(len(devices)):
        print(devices[i])
        thread[i]=threading.Thread(target=(sendTxt), args=(devices[i],))
        thread[i].start()
        if (i+1)%5==0:
            thread[i].join()
    print('done!')
----------------------------------------------

btRecv.py

"""
A simple Python script to receive messages from a client over 
Bluetooth using PyBluez (with Python 2). 
"""

import bluetooth 

hostMACAddress = 'F0:EE:10:9C:9D:9F' # The MAC address of a Bluetooth adapter on the server. The server might have multiple Bluetooth adapters. 
port = 3 
backlog = 1
size = 1024
s = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
s.bind((hostMACAddress, port))
s.listen(backlog)
try:
    client, clientInfo = s.accept()
    while 1:
        data = client.recv(size)
        if data:
            print(data)
            client.send(data) # Echo back to client
except: 
    print("Closing socket")
    client.close()
    s.close()

------------------------------------
btrfcom.py

import bluetooth
import bluetoothctl

bl = bluetoothctl.Bluetoothctl()
bl.make_discoverable()
bl.make_pairable()

server_sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
server_sock.bind(("", bluetooth.PORT_ANY))
server_sock.listen(1)

port = server_sock.getsockname()[1]

uuid = "94f39d29-7d6d-437d-973b-fba39e49d4ee"

bluetooth.advertise_service(server_sock, "SampleServer", service_id=uuid,
                            service_classes=[uuid, bluetooth.SERIAL_PORT_CLASS],
                            profiles=[bluetooth.SERIAL_PORT_PROFILE],
                            # protocols=[bluetooth.OBEX_UUID]
                            )

print("Waiting for connection on RFCOMM channel", port)

client_sock, client_info = server_sock.accept()
print("Accepted connection from", client_info)

try:
    while True:
        data = client_sock.recv(1024)
        if not data:
            break
        print("Received", data)
except OSError:
    pass

print("Disconnected.")

client_sock.close()
server_sock.close()
print("All done.")

----------------------------------------
camera.py

from picamera import PiCamera
from time import sleep
def camera():
    camera = PiCamera()
    camera.rotation=180
    camera.start_preview()
    sleep(2)
    camera.capture('/home/pi/Desktop/communication/currentImage.jpg')
    camera.stop_preview()

-----------------------------------
communicationMain.py

from verification_code_generator import *
from bluetoothInterface import *
from fb_login import *
from fb_dataTransfer import *
from sendImage import *
import datetime
import adjustEnvironment
import camera

date = str(datetime.datetime.now()).split('.')[0]

#config = {
#  "apiKey": "AIzaSyAdCDEsVZNPR6yLCLU4Uw1nfRL5Y81d0oM",
#  "authDomain": "sendinp-82afc.firebaseapp.com",
#  "databaseURL": "https://sendinp-82afc-default-rtdb.europe-west1.firebasedatabase.app",
#  "projectId": "sendinp-82afc",
#  "storageBucket": "sendinp-82afc.appspot.com",
#  "messagingSenderId": "28896690730",
#  "appId": "1:28896690730:web:676261d0ae3b8108d27953",
#  "measurementId": "G-N3NBSVNZP5"
#}

config = {
  "apiKey": "AIzaSyAh4E_pircbhwvcABXk1YagZ-qDJGHTtKw",
  "authDomain": "smartgreenhouse-f8f1a.firebaseapp.com",
  "databaseURL": "https://smartgreenhouse-f8f1a-default-rtdb.firebaseio.com",
  "projectId": "smartgreenhouse-f8f1a",
  "storageBucket": "smartgreenhouse-f8f1a.appspot.com",
  "messagingSenderId": "641487100363",
  "appId": "1:641487100363:web:0e22d8564137acde283e4e",
  "measurementId": "G-0CYTVPF4BX"
}

data = {
"moisture": 0,
"temperature": 0,
"growth": "ripe",
}

[token,uid] = fb_login("burakosman.uz@gmail.com","111111",config)
verificationCode = verification_code_generator(token, uid, config)
#bluetoothInterface()


fb_sendInputs(config,token,data,verificationCode)
moistureData=[1,1,1,1,1]

while True:
    date = str(datetime.datetime.now()).split('.')[0]
    t = date.split(' ')[1][:-3]
    requests = fb_receiveRequests(config,token,verificationCode)
    inputs=adjustEnvironment.runProcess(requests['mode'],requests['plant'],moistureData,requests['heater'],requests['Fan'],requests['Irrigation System'])
    moistureData = inputs["moistureData"]
    data["moisture"] = inputs["moisture"]
    data["temperature"] = inputs["temperature"]
    fb_sendInputs(config,token,data,verificationCode)
    if t=='13:00':
        camera.camera()
        sendImage(config, token, verificationCode, date)

--------------------------------------
fan.py
import RPi.GPIO as GPIO
from time import sleep
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)

def fan(activation,pin=26):
    FAN_PIN = pin
    GPIO.setup(FAN_PIN, GPIO.OUT)
    GPIO.output(FAN_PIN, not activation)
---------------------------------------------

fb_dataTransfer.py

import pyrebase

def fb_sendInputs(config,token,data,verificationCode):
    firebase = pyrebase.initialize_app(config)
    db = firebase.database()
    
    print(data)
    db.child("SmartGreenHouse").child(str(verificationCode)).child("Condition").set(data,token)
    
def fb_receiveRequests(config,token,verificationCode):
    firebase = pyrebase.initialize_app(config)
    db = firebase.database()
    getInfo= db.child("SmartGreenHouse").child(str(verificationCode)).child("Requests").get(token)
    mode = db.child("SmartGreenHouse").child(str(verificationCode)).child("Mode").get(token).val()
    plant = db.child("SmartGreenHouse").child(str(verificationCode)).child("Plant").get(token).val()
    infos = {str(info.key()): info.val() for info in getInfo.each()}
    infos["mode"]=mode
    infos["plant"]=plant
    return infos

------------------------------------
fb_login.py


import pyrebase
def fb_login(email,password,config,auth_num=None):
    firebase = pyrebase.initialize_app(config)
    # Get a reference to the auth service
    auth = firebase.auth()
    database = firebase.database()
    # Log the user in
    user = auth.sign_in_with_email_and_password(email, str(password))
    
    # Get a reference to the database service
    
    # data to save
    data = {
        "auth num": auth_num,
        "user_token":user['idToken']
    }
    if auth_num != None:
        results = database.child("Users").child(user['localId']).set(data,user['idToken'])
    else:
        data = {
        "auth_num": "none",
        "user_token":user['idToken']
    }
        results = database.child("Users").child(user['localId']).set(data,user['idToken'])
        
    # getInfo= database.child('SmartGreenhouse').child('Condition').get(user['idToken'])
    # for info in getInfo.each():
    #     print(str(info.key()) + ': '+ str(info.val()))
        
    return [user['idToken'],user['localId']]

---------------------------------------------

heater.py

import RPi.GPIO as GPIO
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
    
def heater(activation, pin = 21):
    FAN_PIN = pin
    GPIO.setup(FAN_PIN, GPIO.OUT)
    GPIO.output(FAN_PIN, activation)

---------------------------------------
sendImage.py

# -*- coding: utf-8 -*-
"""
Created on Tue Apr  5 18:42:07 2022

@author: Osman Uz1
"""

import pyrebase

def sendImage(config, token, verificationCode, date):
    firebase = pyrebase.initialize_app(config)
    storage = firebase.storage()
    storage.child(str(verificationCode)+"/currentImage.jpg").put("currentImage.jpg", token)
    storage.child(str(verificationCode)+"/oldPictures/"+date+".jpg").put("currentImage.jpg", token)

------------------------------------
soil.py

import RPi.GPIO as GPIO

GPIO.setmode(GPIO.BCM)
#GPIO SETUP
def moisture(channel=16):
    GPIO.setup(channel, GPIO.IN)
    return not GPIO.input(channel)

-----------------------------
temperature.py

from w1thermsensor import W1ThermSensor

def measureTemperature():
    sensor = W1ThermSensor()
    temperature = sensor.get_temperature()
    print("The temperature is %s celsius" % temperature)
    return temperature

    
-------------------------------------------
valve.py


import RPi.GPIO as GPIO
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
def valve(activation, pin=20):
    FAN_PIN = pin
    GPIO.setup(FAN_PIN, GPIO.OUT)
    GPIO.output(FAN_PIN, not activation)
-------------------------------------------
wifiConnect.py

#!/usr/bin/python

import os

def connect(goal_ssid,goal_pw=None):
    # "" important in wpa.conf or it would not work
    goal_ssid = '"' + goal_ssid + '"'   
    
    # Reconfigure goal wifi and key in line 6 and 7 of wpa_supplicant.conf
    cm = "sudo sed -i '6s/.*/        ssid=" + goal_ssid + "/' /etc/wpa_supplicant/wpa_supplicant.conf" # using % does not work with all the "" being important in the wpa.conf
    os.system(cm)
    if goal_pw==None:
        cm = "sudo sed -i '7s/.*//' /etc/wpa_supplicant/wpa_supplicant.conf" # using % does not work with all the "" being important in the wpa.conf
        cm = "sudo sed -i '8s/.*/        key_mgmt=NONE/' /etc/wpa_supplicant/wpa_supplicant.conf" # using % does not work with all the "" being important in the wpa.conf
    else:
        goal_pw = '"' + goal_pw + '"'
        cm = "sudo sed -i '8s/.*/        key_mgmt=WPA-PSK/' /etc/wpa_supplicant/wpa_supplicant.conf" # using % does not work with all the "" being important in the wpa.conf
        os.system(cm)
        cm = "sudo sed -i '7s/.*/        psk=" + goal_pw + "/' /etc/wpa_supplicant/wpa_supplicant.conf" # using % does not work with all the "" being important in the wpa.conf
    os.system(cm)

    # Activate new configuration
    cm = "sudo wpa_cli -i wlan0 reconfigure"
    os.system(cm)
-------------------------------------------
verification.txt

36936

---------------------
